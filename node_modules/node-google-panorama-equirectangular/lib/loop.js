/**
 * node-sync-async-loop
 * marson.laza@gmail.com
 * @idjitjohn
 * version 0.1
 */

module.exports = loop

function chunk(array, size) {
  const chunked_arr = [];
  let index = 0;
  while (index < array.length) {
    chunked_arr.push(array.slice(index, size + index));
    index += size;
  }
  return chunked_arr;
}

function loop(arr, callback, endCallback, indexStartAt = 0){
  arr.reduce((prev, elt, index) => {
    return new Promise(resolve => {
      const f = done => callback(elt, (err, new_elt) => {
        if(!done) done = { tab: [], err: null}
        done.tab.push(new_elt)
        if(err) done.err = err
        resolve(done)
      }, index + indexStartAt)
      if(prev) prev.then(done => {f(done)})
      else f()
    })
  }, false).then(done => {
    if(endCallback) endCallback(done.err, done.tab)
  })
}

loop.parallel = (arr, callback, endCallback, indexStartAt = 0) => {
  let error = null
  const all = arr.map((elt, index) => {
    return new Promise(resolve => {
      callback(elt, (err, new_elt) => {
        if(err) error = err
        resolve(new_elt)
      }, index + indexStartAt)
    })
  })

  Promise.all(all).then(nArr => {
    if(endCallback) endCallback(error, nArr)
  })
}

loop.chunk = (arr, chunkItemNumber, callback, endCallback) => {
  arr = chunk(arr, chunkItemNumber)
  loop(arr, (val, next, index) => {
    loop.parallel(val, callback, (err, all) => {
      next(err, all)
    }, index * val.length)
  },(err, all) => {
    if (endCallback) endCallback(err, all.reduce((acc, val) => acc.concat(val)))
  })
}

loop.parallelChunk = (arr, chunkItemNumber, callback, endCallback) => {
  arr = chunk(arr, chunkItemNumber)
  loop.parallel(arr, (val, next, index) => {
    loop(val, callback,(err, all) => {
      next(err, all)
    }, index * val.length)
  },(err, all) => {
    if (endCallback) endCallback(err, all.reduce((acc, val) => acc.concat(val)))
  })
}
